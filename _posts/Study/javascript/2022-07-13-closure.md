---
title: "[JavaScript] 클로저(Closures)"
categories: JavaScript
last_modified_at: 2022-07-14
---

## 클로저(Closures)란?

클로저란 함수가 중첩된 상황에서 내부 함수가 자신이 선언된 어휘적 환경을 기억하고, 외부 함수가 이미 반환이 완료되어 소멸한 상황에서도 내부 함수가 외부 함수에 존재하는 변수를 필요로 한다면 그 변수를 계속 사용할 수 있는 것을 의미한다.

## 작동 방식

```js
function outer() {
  const value = "outer";

  function inner() {
    console.log(value);
  }

  inner();
}

outer();
```

이 예시의 `inner`는 자신이 선언된 시점을 기준으로 렉시컬 스코핑이 이루어지기 때문에 상위 스코프인 `outer` 함수를 탐색하여 `value` 값을 출력할 수 있다. 즉, 이 코드는 다음과 같은 순서로 작동한다.

1. `outer` 함수가 호출된다.
2. `inner` 함수가 호출된다.
3. `inner` 함수는 지역 스코프 내에서 `value`를 탐색하고, 존재하지 않아 탐색에 실패한다.
4. 렉시컬 스코핑에 따라 선언 시점에서 상위 스코프인 `outer`에서 `value`를 탐색한다.
5. `value`를 발견하였으므로 `"outer"`를 출력한다.

이 코드는 스코프에 대한 기본적인 이해만으로도 충분히 코드 작동을 예상할 수 있다.

그러나,

```js
function outer() {
  const value = "outer";

  const inner = function () {
    console.log(value);
  };

  return inner;
}

const getInner = outer();
getInner();
```

이 예시의 경우 `outer` 함수는 호출되어 `inner` 함수를 반환하고, 이를 `getInner` 변수에 할당함에 따라 역할을 마치고 소멸했다. 즉, `getInner`에는

```js
function() {console.log(value)}
```

만 남게 되어 `value`라는 값 자체가 유효하지 않은 코드가 할당된 것처럼 보인다. 하지만 실제로 코드를 실행해보면 코드는 다음과 같은 순서로 작동한다.

1. `outer` 함수가 호출된다.
2. `inner` 함수가 반환되어 `getInner` 변수에 할당 된다.
3. `getInner` 함수가 호출된다.
4. `getInner` 함수는 지역 스코프 내에서 `value`를 탐색하고, 존재하지 않아 탐색에 실패한다.
5. `getInner` 함수에 할당된 `inner` 함수가 선언된 시점의 렉시컬 환경을 기억하여 해당 환경에서 렉시컬 스코핑이 이루어진다.
6. 기억된 환경에서의 렉시컬 스코핑에 따라 상위 스코프인 `outer`에서 `value`를 탐색한다.
7. `value`를 발견하였으므로 `"outer"`를 출력한다.

이렇듯 `getInner` 함수가 자신이 생성될 당시에 할당된 `inner` 함수의 렉시컬 환경을 기억하고, 그 안에서 스코핑이 가능한 것을 클로저라고 부른다.

## 클로저의 활용

자바스크립트에서 클로저는 다양하게 활용될 수 있으며 이를 통해 효율적인 코드를 작성할 수 있다.

### 상태 유지

클로저를 활용하면 현재 상태를 기억하고 변경된 최신 상태를 유지할 수 있다. 이는 클로저가 생성될 당시의 렉시컬 환경을 기억하고, 따라서 그 기억된 환경은 소멸되지 않은 채로 최신 상태를 계속해서 유지한다는 점을 활용한 것이다.

#### 예시

토글 버튼을 누를 때마다 문구가 사라졌다가 나타나도록 하는 코드를 작성해볼 수 있다.

```html
<!-- HTML -->
<div class="content">토글 버튼을 눌러보세요.</div>
<button class="toggle">토글</button>
```

```js
const content = document.querySelector(".content");
const toggleButton = document.querySelector(".toggle");

const onToggleClick = function () {
  let isVisible = false;

  return function () {
    content.style.display = isVisible ? "block" : "none";

    isVisible = !isVisible;
  };
};

toggleButton.onclick = onToggleClick;
```

이 코드의 작동 방식은 다음과 같다.

1. `onToggleClick`은 함수를 반환하고 소멸한다. 이 때, 반환된 함수는 생성될 때의 렉시컬 환경을 기억하므로 `isVisible`을 기억하는 클로저이다.
2. 반환된 함수를 `onclick`에 할당한다. `onclick`에 할당이 되는 동시에 클로저는 자신의 렉시컬 환경을 계속해서 기억하기 때문에 `isVisible` 또한 소멸하지 않는다.
3. 버튼을 클릭하면 `onclick`에 할당된 클로저가 호출된다. `isVisible`의 값이 변경되고, 이는 렉시컬 환경에서 변경된 최신 상태가 계속해서 유지된다.

참고: [MDN - Closures](https://developer.mozilla.org/ko/docs/Web/JavaScript/Closures){:target="\_blank"}  
참고: [PoiemaWeb](https://poiemaweb.com/js-closure){:target="\_blank"}
